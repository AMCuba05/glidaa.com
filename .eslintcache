[{"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\index.js":"1","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\reportWebVitals.js":"2","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\App.tsx":"3","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\Introduction\\scrollyTellerConfig.js":"4","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\Introduction\\data\\slides\\index.js":"5","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\utils.js":"6","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\data\\Graphic\\index.tsx":"7","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\ScrollyTeller.js":"8","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\isTouchDevice.js":"9","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\CSSNames.js":"10","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\CSSNameDefaults.js":"11","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\index.js":"12","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\narrationBuilder.js":"13","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\triggerUtils.js":"14","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\configValidator.js":"15","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\googleAnalytics.js":"16","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\fetchUtils.js":"17","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\graphUpdates.js":"18","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\scrollProgress.js":"19","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\vhToPxFunctions.js":"20"},{"size":517,"mtime":1610692888604,"results":"21","hashOfConfig":"22"},{"size":375,"mtime":1610689911563,"results":"23","hashOfConfig":"22"},{"size":4441,"mtime":1610707984667,"results":"24","hashOfConfig":"22"},{"size":1604,"mtime":1610707744203,"results":"25","hashOfConfig":"22"},{"size":178,"mtime":1610691143263,"results":"26","hashOfConfig":"22"},{"size":1158,"mtime":1610697290466,"results":"27","hashOfConfig":"22"},{"size":1514,"mtime":1610707018119,"results":"28","hashOfConfig":"22"},{"size":23868,"mtime":1610702403477,"results":"29","hashOfConfig":"22"},{"size":1029,"mtime":1610697427474,"results":"30","hashOfConfig":"22"},{"size":3999,"mtime":1610697427459,"results":"31","hashOfConfig":"22"},{"size":365,"mtime":1610697427457,"results":"32","hashOfConfig":"22"},{"size":313,"mtime":1610697427473,"results":"33","hashOfConfig":"22"},{"size":4140,"mtime":1610697427476,"results":"34","hashOfConfig":"22"},{"size":1310,"mtime":1610697427479,"results":"35","hashOfConfig":"22"},{"size":3604,"mtime":1610697427464,"results":"36","hashOfConfig":"22"},{"size":4001,"mtime":1610697427470,"results":"37","hashOfConfig":"22"},{"size":3542,"mtime":1610697427468,"results":"38","hashOfConfig":"22"},{"size":2387,"mtime":1610697427471,"results":"39","hashOfConfig":"22"},{"size":399,"mtime":1610697427477,"results":"40","hashOfConfig":"22"},{"size":341,"mtime":1610697427480,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"djchla",{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"44"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"44"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"44"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"44"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"44"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88","usedDeprecatedRules":"44"},"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\index.js",[],["89","90"],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\reportWebVitals.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\App.tsx",["91"],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\Introduction\\scrollyTellerConfig.js",["92"],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\Introduction\\data\\slides\\index.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\utils.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\data\\Graphic\\index.tsx",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\ScrollyTeller.js",["93","94"],"/* global document, window */\r\nimport {\r\n  get,\r\n  forEach,\r\n  isEmpty,\r\n  isNil,\r\n  isNumber,\r\n  isString,\r\n  isUndefined,\r\n  keyBy,\r\n  noop,\r\n} from 'lodash-es';\r\nimport isTouchDevice from './utils/isTouchDevice';\r\nimport elementResizeDetectorMaker from 'element-resize-detector';\r\nimport { select } from 'd3-selection';\r\nimport * as utils from './utils';\r\nimport scrollIntoView from 'scroll-into-view';\r\nimport 'intersection-observer';\r\nimport scrollama from 'scrollama';\r\nimport CSSNames from './utils/CSSNames';\r\n\r\n// How far from the top of the viewport to trigger a step.\r\nconst TRIGGER_OFFSET = 0.5;\r\n\r\nexport default class ScrollyTeller {\r\n  /**\r\n   * Validates scrollyTellerConfig, converts any narration or data promises in the sectionList to arrays of data\r\n   * or narration, and builds the HTML necessary for a scrolling story\r\n   * @param {object} config object containing configuration\r\n   */\r\n  constructor(config) {\r\n    utils.validateScrollyTellerConfig(config);\r\n\r\n    this.appContainerId = config.appContainerId;\r\n    this.sectionList = keyBy(config.sectionList, 'sectionIdentifier');\r\n    this.onNarrationChangedFunction = config.onNarrationChangedFunction || noop;\r\n    /** multiply minHeightVh, marginTopVh, and marginBottomVh by this factor on mobile to\r\n     * pad scrolling */\r\n    this.mobileScrollHeightMultiplier = config.mobileScrollHeightMultiplier || 1;\r\n\r\n    /** state to handle advancing to previous/next narration and time tracking */\r\n    this.sectionNamesArray = config.sectionList.map(({ sectionIdentifier }) => (sectionIdentifier));\r\n    this.currentSectionId = null;\r\n    this.currentNarrationIndex = null;\r\n\r\n    /** store the current trigger state */\r\n    this.triggerState = {};\r\n    this.trigger = '';\r\n\r\n    /** state to handle google analytics tracking */\r\n    this.sendSectionAnalytics = config.sendSectionAnalytics || false;\r\n    this.sendNarrationAnalytics = config.sendNarrationAnalytics || false;\r\n    this.sendScrollToAnalytics = config.sendScrollToAnalytics || false;\r\n    this.maxTimeInSeconds = config.maxTimeInSeconds || Infinity;\r\n    this.timeEnteredCurrentSection = null;\r\n    this.timeEnteredCurrentNarration = null;\r\n    this.pageLoadStartTime = new Date();\r\n\r\n    /** if cssNames is unassigned,\r\n     * use the default CSSNames constructor to create a new one */\r\n    if (isUndefined(config.cssNames) || (config.cssNames.constructor.name !== 'CSSNames')) {\r\n      this.cssNames = new CSSNames();\r\n    } else {\r\n      this.cssNames = config.cssNames;\r\n    }\r\n\r\n    this._assignConfigVariablesToSectionConfigs(this.cssNames);\r\n\r\n    this._triggersDisabled = false;\r\n  }\r\n\r\n  /** 'PRIVATE' METHODS * */\r\n\r\n  _assignConfigVariablesToSectionConfigs() {\r\n    forEach(this.sectionList, (section, sectionIdentifier) => {\r\n      section.appContainerId = this.appContainerId;\r\n      section.cssNames = this.cssNames;\r\n      section.sectionIndex = this._sectionIndexFromSectionIdentifier(sectionIdentifier);\r\n    });\r\n  }\r\n\r\n  _graphIdForSection(config) {\r\n    return config.cssNames.graphId(config.sectionIdentifier);\r\n  }\r\n\r\n  _buildGraphs() {\r\n    forEach(this.sectionList, (config) => {\r\n      const { state } = this._triggerState({ sectionConfig: config, index: 0, progress: 0 });\r\n      this.triggerState = state;\r\n\r\n      const containerId = config.cssNames.graphContainerId(config.sectionIdentifier)\r\n      this._updateTitleAndCaption({\r\n        graphContainer: select(`#${containerId}`),\r\n        index: 0,\r\n        names: config.cssNames,\r\n        narration: config.narration,\r\n        state,\r\n      });\r\n\r\n      config.graph = config.buildGraphFunction(this._graphIdForSection(config), config);\r\n    });\r\n  }\r\n\r\n  _triggerState({ sectionConfig, index, progress }) {\r\n    if (isNil(sectionConfig) || isNil(index)) {\r\n      return { trigger: '', state: {} };\r\n    }\r\n    const {\r\n      narration,\r\n      convertTriggerToObject = true,\r\n    } = sectionConfig;\r\n\r\n    const trigger = (convertTriggerToObject)\r\n      ? utils.getStateFromTrigger(narration[index].trigger, { index, progress })\r\n      : narration[index].trigger || '';\r\n\r\n    const state = (convertTriggerToObject)\r\n      ? utils.getNarrationState(sectionConfig, index, progress)\r\n      : {};\r\n\r\n    return { trigger, state };\r\n  }\r\n\r\n  _updateTitleAndCaption({\r\n    graphContainer, index, names, narration, state\r\n  }) {\r\n    utils.updateTitle({\r\n      graphContainer,\r\n      index,\r\n      names,\r\n      narration,\r\n      state,\r\n    });\r\n\r\n    utils.updateCaption({\r\n      graphContainer,\r\n      index,\r\n      names,\r\n      narration,\r\n      state,\r\n    });\r\n  }\r\n\r\n  _handleOnStepEnter(sectionConfig, { element, index, direction }) {\r\n    if (this._triggersDisabled) {\r\n      return;\r\n    }\r\n    const {\r\n      narration,\r\n      cssNames: names,\r\n      sectionIdentifier,\r\n      onActivateNarrationFunction = noop,\r\n    } = sectionConfig;\r\n\r\n    // if google analytics object exists\r\n    if (window.ga) {\r\n      // if user requests SECTION tracking and section has changed\r\n      if (this.sendSectionAnalytics && sectionIdentifier !== this.currentSectionId) {\r\n        // send enter section tracking events\r\n        utils.sendEnteredSectionAnalytics({\r\n          enteringSectionId: sectionIdentifier,\r\n          enteringSectionIndex: this._sectionIndexFromSectionIdentifier(sectionIdentifier),\r\n          pageLoadStartTime: this.pageLoadStartTime,\r\n          maxTimeInSeconds: this.maxTimeInSeconds,\r\n        });\r\n\r\n        // if a previous section is set, send analytics on the section that was exited from\r\n        if (!isNil(this.currentSectionId)) {\r\n          utils.sendExitedSectionAnalytics({\r\n            exitedNarrationIndex: this.currentNarrationIndex,\r\n            exitedSectionId: this.currentSectionId,\r\n            exitedSectionIndex: this._sectionIndexFromSectionIdentifier(this.currentSectionId),\r\n            maxTimeInSeconds: this.maxTimeInSeconds,\r\n            timeEntered: this.timeEnteredCurrentSection || new Date(),\r\n          });\r\n        }\r\n\r\n        this.timeEnteredCurrentSection = new Date();\r\n      }\r\n\r\n      // if user requests NARRATION tracking and section or narration index has changed\r\n      if (\r\n        this.sendNarrationAnalytics\r\n        && (sectionIdentifier !== this.currentSectionId || index !== this.currentNarrationIndex)\r\n      ) {\r\n        // there should always be an entered section identifier: send enter section tracking events\r\n        utils.sendEnteredNarrationAnalytics({\r\n          enteringNarrationIndex: index,\r\n          enteringSectionId: sectionIdentifier,\r\n          enteringSectionIndex: this._sectionIndexFromSectionIdentifier(sectionIdentifier),\r\n          pageLoadStartTime: this.pageLoadStartTime,\r\n          maxTimeInSeconds: this.maxTimeInSeconds,\r\n        });\r\n\r\n        // if a previous section is set, send analytics on the section that was exited from\r\n        if (!isNil(this.currentNarrationIndex)) {\r\n          utils.sendExitedNarrationAnalytics({\r\n            exitingNarrationIndex: this.currentNarrationIndex,\r\n            exitedSectionId: this.currentSectionId,\r\n            exitedSectionIndex: this._sectionIndexFromSectionIdentifier(this.currentSectionId),\r\n            maxTimeInSeconds: this.maxTimeInSeconds,\r\n            timeEntered: this.timeEnteredCurrentNarration || new Date(),\r\n          });\r\n        }\r\n        this.timeEnteredCurrentNarration = new Date();\r\n      }\r\n    }\r\n\r\n    this.currentSectionId = sectionIdentifier;\r\n    this.currentNarrationIndex = index;\r\n    this.onNarrationChangedFunction({\r\n      sectionIdentifier: this.currentSectionId,\r\n      narrationIndex: this.currentNarrationIndex,\r\n      narrationId: get(sectionConfig, ['narration', index, 'narrationId']),\r\n      narrationClass: get(sectionConfig, ['narration', index, 'narrationClass']),\r\n    });\r\n\r\n    const graphId = names.graphId(sectionIdentifier);\r\n    const graphContainerId = names.graphContainerId(sectionIdentifier);\r\n\r\n    const progress = 0;\r\n\r\n    const { trigger, state } = this._triggerState({ sectionConfig, index, progress });\r\n    this.triggerState = state;\r\n\r\n    select(element).classed('active', true);\r\n    const graphContainer = select(`#${graphContainerId}`).classed('active', true);\r\n    const graph = select(`#${graphId}`);\r\n\r\n    this._updateTitleAndCaption({\r\n      graphContainer,\r\n      index,\r\n      names,\r\n      narration,\r\n      state,\r\n    });\r\n\r\n    utils.updateGraphStyles({\r\n      graph,\r\n      graphContainer,\r\n      names,\r\n      sectionIdentifier,\r\n      state,\r\n    });\r\n\r\n    onActivateNarrationFunction({\r\n      index,\r\n      progress,\r\n      element,\r\n      trigger,\r\n      state,\r\n      direction,\r\n      graphId,\r\n      graphContainerId,\r\n      sectionConfig,\r\n    });\r\n  }\r\n\r\n  _handleOnStepExit(sectionConfig, { index, element, direction }) {\r\n    if (this._triggersDisabled) {\r\n      return;\r\n    }\r\n    const {\r\n      narration,\r\n      cssNames: names,\r\n      sectionIdentifier,\r\n    } = sectionConfig;\r\n\r\n    select(element).classed('active', false);\r\n\r\n    if ((index === narration.length - 1 && direction === 'down')\r\n      || (index === 0 && direction === 'up')\r\n    ) {\r\n      const graphContainerId = `#${names.graphContainerId(sectionIdentifier)}`;\r\n      select(graphContainerId).classed('active', false);\r\n\r\n      /** check for scrolling out of the story and set current id and section to null */\r\n      const sectionIndex = this._sectionIndexFromSectionIdentifier(sectionIdentifier);\r\n      if ((sectionIndex === 0 && direction === 'up')\r\n        || (sectionIndex === this.sectionNamesArray.length - 1 && direction === 'down')) {\r\n        this.currentNarrationIndex = null;\r\n        this.currentSectionId = null;\r\n        this.onNarrationChangedFunction({\r\n          sectionIdentifier: null,\r\n          narrationIndex: null,\r\n          narrationId: null,\r\n          narrationClass: null,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  _handleOnStepProgress(sectionConfig, { element, scrollProgressElement, index }) {\r\n    if (this._triggersDisabled) {\r\n      return;\r\n    }\r\n    const {\r\n      cssNames: names,\r\n      sectionIdentifier,\r\n      onScrollFunction = noop,\r\n    } = sectionConfig;\r\n\r\n    const graphId = names.graphId(sectionIdentifier);\r\n    const graphContainerId = names.graphContainerId(sectionIdentifier);\r\n\r\n    /** recalculate scroll progress due to intersection observer bug in Chrome\r\n     *  https://github.com/russellgoldenberg/scrollama/issues/64\r\n     *  TODO: revert back to using scrollama progress if/when issue is resolved */\r\n    const progress = utils.calcScrollProgress(scrollProgressElement || element, TRIGGER_OFFSET);\r\n\r\n    const { trigger, state } = this._triggerState({ sectionConfig, index, progress });\r\n    this.triggerState = state;\r\n\r\n    utils.updateGraphStyles({\r\n      graph: select(`#${graphId}`),\r\n      graphContainer: select(`#${graphContainerId}`),\r\n      names,\r\n      sectionIdentifier,\r\n      state,\r\n    });\r\n\r\n    onScrollFunction({\r\n      index,\r\n      progress,\r\n      element,\r\n      trigger,\r\n      state,\r\n      graphId,\r\n      graphContainerId,\r\n      sectionConfig,\r\n    });\r\n  }\r\n\r\n  _buildScrollamaContainers() {\r\n    forEach(this.sectionList, (sectionConfig) => {\r\n      const css = get(sectionConfig, ['cssNames', 'css']);\r\n\r\n      const {\r\n        cssNames: names,\r\n        sectionIdentifier,\r\n      } = sectionConfig;\r\n\r\n      sectionConfig.scroller = scrollama();\r\n\r\n      const sectionId = names.sectionId(sectionIdentifier);\r\n\r\n      sectionConfig.scroller\r\n        .setup({\r\n          step: `#${sectionId} .${css.narrationBlock}`,\r\n          offset: TRIGGER_OFFSET,\r\n          progress: true,\r\n        })\r\n        .onStepEnter((payload) => { this._handleOnStepEnter(sectionConfig, payload); })\r\n        .onStepExit((payload) => { this._handleOnStepExit(sectionConfig, payload); })\r\n        .onStepProgress((payload) => { this._handleOnStepProgress(sectionConfig, payload); });\r\n    });\r\n  }\r\n\r\n  _buildKeyboardListeners() {\r\n    // prevent default scroll using spacebar and arrow keys\r\n    document.addEventListener('keydown', (event) => {\r\n      const key = event.key || event.keyCode;\r\n\r\n      if (event.target === document.body) {\r\n        switch (key) {\r\n          case ' ':\r\n          case 'ArrowDown':\r\n          case 'ArrowRight':\r\n          case 'ArrowUp':\r\n          case 'ArrowLeft':\r\n            event.preventDefault();\r\n            break;\r\n          default:\r\n        }\r\n      }\r\n    });\r\n\r\n    document.addEventListener('keyup', (event) => {\r\n      if (event.defaultPrevented) {\r\n        return;\r\n      }\r\n\r\n      if (event.target === document.body) {\r\n        const key = event.key || event.keyCode;\r\n\r\n        switch (key) {\r\n          case ' ':\r\n          case 'ArrowDown':\r\n          case 'ArrowRight':\r\n            this.scrollToNextNarration();\r\n            break;\r\n          case 'ArrowUp':\r\n          case 'ArrowLeft':\r\n            this.scrollToPreviousNarration();\r\n            break;\r\n          default:\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _buildResizeListeners() {\r\n    forEach(this.sectionList, (sectionConfig) => {\r\n      const {\r\n        cssNames: names,\r\n        onResizeFunction = noop,\r\n        sectionIdentifier,\r\n      } = sectionConfig;\r\n\r\n      const graphId = names.graphId(sectionIdentifier);\r\n      const graphContainerId = names.graphContainerId(sectionIdentifier);\r\n\r\n      sectionConfig.elementResizeDetector = elementResizeDetectorMaker({\r\n        strategy: 'scroll',\r\n      });\r\n\r\n      sectionConfig.elementResizeDetector\r\n        .listenTo(\r\n          select(`#${graphId}`).node(),\r\n          (element) => {\r\n            onResizeFunction({\r\n              graphElement: element,\r\n              graphContainerId,\r\n              graphId,\r\n              sectionConfig,\r\n              state: this.triggerState,\r\n              trigger: this.triggerState,\r\n            });\r\n          },\r\n        );\r\n    });\r\n  }\r\n\r\n  _buildSections() {\r\n    select(`#${this.appContainerId}`)\r\n      .append('div')\r\n      .attr('class', this.cssNames.scrollContainer());\r\n\r\n    const mobileScrollHeightMultiplier = isTouchDevice()\r\n      ? this.mobileScrollHeightMultiplier\r\n      : 1;\r\n    forEach(\r\n      this.sectionList,\r\n      config => (utils.buildSectionWithNarration(config, mobileScrollHeightMultiplier)),\r\n    );\r\n  }\r\n\r\n  _sectionIndexFromSectionIdentifier(sectionIdentifier) {\r\n    return this.sectionNamesArray.findIndex(\r\n      (id) => { return id === sectionIdentifier; },\r\n    );\r\n  }\r\n\r\n  /** 'PUBLIC' METHODS * */\r\n\r\n  /**\r\n   * Converts all narration promises to data, and all data promises to processed data,\r\n   * then build all the necessary HTML\r\n   * @returns {Promise<void>} that is resolved when everything is built\r\n   */\r\n  async render() {\r\n    await utils.fetchNarration(this.sectionList);\r\n    await utils.fetchDataAndProcessResults(this.sectionList);\r\n    /** then build the html we need along with the graph scroll objects for each section */\r\n    this._buildSections();\r\n    this._buildScrollamaContainers();\r\n    this._buildGraphs();\r\n    this._buildResizeListeners();\r\n    this._buildKeyboardListeners();\r\n\r\n    if (isTouchDevice()) {\r\n      window.addEventListener('orientationchange', () => {\r\n        const afterOrientationChange = () => {\r\n          this._handleResizeEvent();\r\n          window.removeEventListener('resize', afterOrientationChange);\r\n        };\r\n        window.addEventListener('resize', afterOrientationChange);\r\n      });\r\n    } else {\r\n      window.addEventListener('resize', () => {\r\n        this._handleResizeEvent();\r\n      });\r\n    }\r\n  }\r\n\r\n  _handleResizeEvent() {\r\n    const mobileScrollHeightMultiplier = isTouchDevice()\r\n      ? this.mobileScrollHeightMultiplier\r\n      : 1;\r\n    forEach(this.sectionList, (config) => {\r\n      utils.resizeNarrationBlocks(config, mobileScrollHeightMultiplier);\r\n      config.scroller.resize();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @param {string|number} sectionIdentifier - `sectionIdentifier` of the target section\r\n   * @param {string|number|undefined} [narrationIdStringOrNumericIndex]\r\n   *  - optional: if undefined, defaults to the first narration block of target section\r\n   *              if number, argument is treated as the index of the narration block to scroll to\r\n   *              if string, argument is treated as the `narrationId` of the target narration block\r\n   * @param {object} [options] - optional: configuration object passed to `scrollIntoView`\r\n   *              (https://github.com/KoryNunn/scroll-into-view)\r\n   * @returns {Promise<void>} - returns empty promise\r\n   */\r\n  async scrollTo(sectionIdentifier, narrationIdStringOrNumericIndex, options) {\r\n    if (isNil(sectionIdentifier) || isNil(narrationIdStringOrNumericIndex)) {\r\n      return;\r\n    }\r\n    const {\r\n      appContainerId,\r\n      cssNames,\r\n      currentNarrationIndex,\r\n      currentSectionId,\r\n      sectionList,\r\n    } = this;\r\n\r\n    // Find the sectionConfig.\r\n    const sectionConfig = get(sectionList, sectionIdentifier);\r\n    if (isNil(sectionConfig)) {\r\n      return;\r\n    }\r\n\r\n    // Find the index of the target narration block to scroll to.\r\n    let index = 0; // undefined case, treat as zero index\r\n    // string case: treat as narration id\r\n    if (isString(narrationIdStringOrNumericIndex)) {\r\n      index = sectionConfig.narration.findIndex(\r\n        // eslint-disable-next-line eqeqeq\r\n        (block) => { return block.narrationId === narrationIdStringOrNumericIndex; },\r\n      ) || 0;\r\n    } else if ( // numeric case: treat as index\r\n      isNumber(narrationIdStringOrNumericIndex)\r\n      && narrationIdStringOrNumericIndex > -1\r\n      && narrationIdStringOrNumericIndex < sectionConfig.narration.length\r\n    ) {\r\n      index = narrationIdStringOrNumericIndex;\r\n    }\r\n\r\n    // if user requests tracking and google analytics object exists\r\n    if (this.sendScrollToAnalytics && window.ga) {\r\n      // send props to handle analytics tracking of the previous section that we just left\r\n      utils.sendScrollToAnalytics({\r\n        enteringSectionId: sectionIdentifier,\r\n        enteringSectionIndex: this._sectionIndexFromSectionIdentifier(sectionIdentifier),\r\n        enteringNarrationIndex: index,\r\n        pageLoadStartTime: this.pageLoadStartTime,\r\n        maxTimeInSeconds: this.maxTimeInSeconds,\r\n        exitedSectionId: currentSectionId,\r\n        exitedSectionIndex: this._sectionIndexFromSectionIdentifier(currentSectionId),\r\n        exitedNarrationIndex: currentNarrationIndex,\r\n      });\r\n    }\r\n\r\n    // create a selector for the target narration block and select that element\r\n    const targetNarrationSelector = [\r\n      `#${cssNames.sectionId(sectionIdentifier)}`,\r\n      `.${cssNames.narrationList()}`,\r\n      `div.${cssNames.narrationClass()}:nth-of-type(${index + 1})`,\r\n    ].join(' ');\r\n    const narrationBlockSelection = select(targetNarrationSelector); // d3 selection\r\n    const narrationBlockElement = narrationBlockSelection.node(); // node\r\n\r\n    // select the content element within the desired narration block, which we'll scroll directly to\r\n    const scrollToContentElement = narrationBlockSelection.select(\r\n      `div.${cssNames.narrationContentClass()}`,\r\n    ).node();\r\n\r\n    // can't find element, return\r\n    if (isNil(scrollToContentElement)) {\r\n      return;\r\n    }\r\n\r\n    // Get the page position, so we can determine which direction we've scrolled.\r\n    const startingYOffset = window.pageYOffset;\r\n\r\n    // Remove CSS class 'active' on all elements within the ScrollyTeller container element.\r\n    select(`#${appContainerId}`).selectAll('.active').classed('active', false);\r\n    // Set a flag to prevent trigger callbacks from executing during scrolling.\r\n    this._triggersDisabled = true;\r\n    // Scroll the page (asynchronously).\r\n    await new Promise((resolve) => {\r\n      scrollIntoView(scrollToContentElement, options, resolve);\r\n    });\r\n    // Re-enable trigger callbacks.\r\n    this._triggersDisabled = false;\r\n\r\n    // Compute the direction of scrolling.\r\n    const direction = window.pageYOffset < startingYOffset ? 'up' : 'down';\r\n    // Manually activate triggers for the current narration (since they won't have fired on scroll).\r\n    this._handleOnStepEnter(sectionConfig, { element: narrationBlockElement, index, direction });\r\n    this._handleOnStepProgress(\r\n      sectionConfig,\r\n      {\r\n        element: narrationBlockElement,\r\n        index,\r\n        scrollProgressElement: scrollToContentElement,\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Scrolls \"up\" to the previous narration block in the story\r\n   * @return {Promise<void>} - returns empty promise\r\n   */\r\n  async scrollToPreviousNarration() {\r\n    const {\r\n      sectionList,\r\n      sectionNamesArray,\r\n    } = this;\r\n    let narrationContentEmtpy = false;\r\n    let destinationSection = this.currentSectionId;\r\n    let destinationNarration = this.currentNarrationIndex;\r\n\r\n    while (!narrationContentEmtpy) {\r\n      const sectionIndex = this._sectionIndexFromSectionIdentifier(destinationSection);\r\n\r\n      destinationSection = sectionIndex === -1 ? sectionNamesArray[0] : destinationSection;\r\n      destinationNarration = destinationNarration === null ? 1 : destinationNarration;\r\n\r\n      const isFirstSection = sectionIndex === 0;\r\n      const isNarrationInPreviousSection = destinationNarration - 1 < 0;\r\n\r\n      if (isNarrationInPreviousSection && !isFirstSection) {\r\n        destinationSection = sectionNamesArray[sectionIndex - 1];\r\n        const currentNarration = get(sectionList, [destinationSection, 'narration']);\r\n        destinationNarration = currentNarration ? currentNarration.length - 1 : 0;\r\n      } else if (!isNarrationInPreviousSection) {\r\n        destinationNarration -= 1;\r\n      } else {\r\n        return;\r\n      }\r\n\r\n      const content = get(\r\n        sectionList,\r\n        [destinationSection, 'narration', destinationNarration],\r\n      );\r\n\r\n      narrationContentEmtpy = !(\r\n        isEmpty(content.hRefText)\r\n        && isEmpty(content.h2Text)\r\n        && isEmpty(content.paragraphText)\r\n      );\r\n    }\r\n\r\n    await this.scrollTo(\r\n      destinationSection,\r\n      destinationNarration,\r\n      { align: { top: 0.5 } },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Scrolls \"down\" to the next narration block in the story\r\n   * @return {Promise<void>} - returns empty promise\r\n   */\r\n  async scrollToNextNarration() {\r\n    const {\r\n      sectionList,\r\n      sectionNamesArray,\r\n    } = this;\r\n    let narrationContentEmtpy = false;\r\n    let destinationSection = this.currentSectionId;\r\n    let destinationNarration = this.currentNarrationIndex;\r\n\r\n    while (!narrationContentEmtpy) {\r\n      const sectionIndex = this._sectionIndexFromSectionIdentifier(destinationSection);\r\n\r\n      destinationSection = sectionIndex === -1 ? sectionNamesArray[0] : destinationSection;\r\n      destinationNarration = destinationNarration === null ? -1 : destinationNarration;\r\n\r\n      const isLastSection = sectionIndex === sectionNamesArray.length - 1;\r\n      const currentSectionNarrationCount = get(\r\n        sectionList,\r\n        [destinationSection, 'narration', 'length'],\r\n        0,\r\n      );\r\n      const isNarrationInNextSection = destinationNarration + 1 === currentSectionNarrationCount;\r\n\r\n      if (isNarrationInNextSection && !isLastSection) {\r\n        destinationSection = sectionNamesArray[sectionIndex + 1];\r\n        destinationNarration = 0;\r\n      } else if (!isNarrationInNextSection) {\r\n        destinationNarration += 1;\r\n      } else {\r\n        return;\r\n      }\r\n\r\n      const content = get(\r\n        sectionList,\r\n        [destinationSection, 'narration', destinationNarration],\r\n      );\r\n\r\n      narrationContentEmtpy = !(\r\n        isEmpty(content.hRefText)\r\n        && isEmpty(content.h2Text)\r\n        && isEmpty(content.paragraphText)\r\n      );\r\n    }\r\n\r\n    await this.scrollTo(\r\n      destinationSection,\r\n      destinationNarration,\r\n      { align: { top: 0.5 } },\r\n    );\r\n  }\r\n}\r\n","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\isTouchDevice.js",["95"],"/* global window */\r\n\r\n/* refactored from: https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent */\r\nexport default function isTouchDevice() {\r\n  const { navigator, matchMedia } = window;\r\n  let hasTouchScreen = false;\r\n  if (\r\n    ('maxTouchPoints' in navigator && navigator.maxTouchPoints > 0)\r\n    || ('msMaxTouchPoints' in navigator && navigator.msMaxTouchPoints > 0)\r\n  ) {\r\n    hasTouchScreen = true;\r\n  } else {\r\n    const mQ = matchMedia && matchMedia('(pointer:coarse)');\r\n    if (mQ && mQ.media === '(pointer:coarse)') {\r\n      hasTouchScreen = !!mQ.matches;\r\n    } else if ('orientation' in window) {\r\n      hasTouchScreen = true; // deprecated, but good fallback\r\n    } else {\r\n      // Only as a last resort, fall back to user agent sniffing\r\n      const UA = navigator.userAgent;\r\n      hasTouchScreen = (\r\n        /\\b(BlackBerry|webOS|iPhone|IEMobile)\\b/i.test(UA)\r\n        || /\\b(Android|Windows Phone|iPad|iPod)\\b/i.test(UA)\r\n      );\r\n    }\r\n  }\r\n  return hasTouchScreen;\r\n}\r\n","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\CSSNames.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\CSSNameDefaults.js",["96"],"export default {\r\n  scrollContainer: 'scroll',\r\n  sectionContainer: 'section',\r\n  narrationList: 'narration_list',\r\n  narrationBlock: 'narration',\r\n  narrationContent: 'narration-content',\r\n  graphContainer: 'graph',\r\n  graphContainerDefault: 'graph_default',\r\n  graphTitleClass: 'graph_title',\r\n  graphCaptionClass: 'graph_caption',\r\n  linkContainer: 'link',\r\n};\r\n","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\index.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\narrationBuilder.js",["97","98","99","100"],"/* global window document */\r\n/* eslint-disable require-jsdoc */\r\nimport {\r\n  get,\r\n  isEmpty,\r\n} from 'lodash-es';\r\nimport { select, selectAll } from 'd3-selection';\r\nimport { vhToPx } from './vhToPxFunctions';\r\n\r\nfunction scaleMarginTop(mobileScrollHeightMultiplier = 1) {\r\n  return function ({ marginTopVh }) {\r\n    return vhToPx(marginTopVh * mobileScrollHeightMultiplier);\r\n  };\r\n}\r\n\r\nfunction scaleMarginBottom(mobileScrollHeightMultiplier = 1) {\r\n  return function ({ marginBottomVh }) {\r\n    return vhToPx(marginBottomVh * mobileScrollHeightMultiplier);\r\n  };\r\n}\r\n\r\nfunction scaleMinHeight(mobileScrollHeightMultiplier = 1) {\r\n  return function ({ minHeightVh, marginTopVh, marginBottomVh }) {\r\n    const scaledHeight = minHeightVh * mobileScrollHeightMultiplier;\r\n    const scaledMarginTop = marginTopVh * mobileScrollHeightMultiplier;\r\n    const scaledMarginBottom = marginBottomVh * mobileScrollHeightMultiplier;\r\n\r\n    return vhToPx(\r\n      scaledHeight || (Number(scaledMarginTop) + Number(scaledMarginBottom)),\r\n    );\r\n  };\r\n}\r\n\r\n\r\nfunction buildNarrationBlocks(\r\n  narrationDiv,\r\n  narrationBlocksArray,\r\n  config,\r\n  mobileScrollHeightMultiplier = 1,\r\n) {\r\n  /** build the narration as an html string */\r\n  const names = config.cssNames;\r\n  const css = get(config, ['cssNames', 'css']);\r\n\r\n  narrationBlocksArray.forEach((block) => {\r\n    const {\r\n      narrationId,\r\n      narrationClass = '',\r\n      h2Text,\r\n      paragraphText,\r\n      hRefText,\r\n      hRef,\r\n    } = block;\r\n\r\n    const narrationBlockId = `${names.narrationId(narrationId)}`;\r\n\r\n    const blockContainer = narrationDiv\r\n      .append('div')\r\n      .datum(block)\r\n      .attr('class', css.narrationBlock)\r\n      .attr('id', narrationBlockId)\r\n      .classed(narrationClass, true)\r\n      .style('margin-top', scaleMarginTop(mobileScrollHeightMultiplier))\r\n      .style('margin-bottom', scaleMarginBottom(mobileScrollHeightMultiplier))\r\n      .style('min-height', scaleMinHeight(mobileScrollHeightMultiplier));\r\n\r\n    const blockContent = blockContainer.append('div')\r\n      .datum(block)\r\n      .attr('class', css.narrationContent);\r\n\r\n    if (!isEmpty(h2Text)) {\r\n      blockContent.append('h2').html(h2Text);\r\n    }\r\n\r\n    if (!isEmpty(paragraphText)) {\r\n      blockContent.append('p').html(paragraphText);\r\n    }\r\n\r\n    if (!isEmpty(hRefText) && !isEmpty(hRef)) {\r\n      blockContent.append('div')\r\n        .attr('class', css.linkContainer)\r\n        .append('a')\r\n        .attr('href', hRef)\r\n        .attr('target', '_blank')\r\n        .html(hRefText);\r\n    }\r\n  });\r\n}\r\n\r\nexport function resizeNarrationBlocks(config, mobileScrollHeightMultiplier) {\r\n  const { sectionIdentifier, cssNames: names } = config;\r\n\r\n  const css = get(names, ['css']);\r\n  const sectionId = names.sectionId(sectionIdentifier);\r\n\r\n  selectAll(`#${sectionId} .${css.narrationBlock}`)\r\n    .style('margin-top', scaleMarginTop(mobileScrollHeightMultiplier))\r\n    .style('margin-bottom', scaleMarginBottom(mobileScrollHeightMultiplier))\r\n    .style('min-height', scaleMinHeight(mobileScrollHeightMultiplier));\r\n}\r\n\r\nexport function buildSectionWithNarration(config, mobileScrollHeightMultiplier) {\r\n  const { sectionIdentifier, cssNames: names, narration } = config;\r\n\r\n  const sectionDiv = select(`.${names.scrollContainer()}`)\r\n    .append('div')\r\n    .attr('class', names.sectionClass())\r\n    .attr('id', names.sectionId(sectionIdentifier));\r\n\r\n  /** insert the graph as the first div before narration divs */\r\n  sectionDiv\r\n    .append('div')\r\n    .attr('id', names.graphContainerId(sectionIdentifier))\r\n    .attr('class', names.graphContainerClassNames(sectionIdentifier))\r\n    .append('div')\r\n    .attr('class', names.graphClassNames(sectionIdentifier))\r\n    .attr('id', names.graphId(sectionIdentifier));\r\n\r\n  const narrationDiv = sectionDiv.append('div')\r\n    .attr('class', names.narrationList());\r\n\r\n  /** select the appropriate section by id, and append a properly formatted html string\r\n   * containing the contents of each narration block (row in the narration.csv file) */\r\n  buildNarrationBlocks(narrationDiv, narration, config, mobileScrollHeightMultiplier);\r\n}\r\n","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\triggerUtils.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\configValidator.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\googleAnalytics.js",["101"],"/* global window */\r\n\r\nfunction padNumberWithZeros(number, width) {\r\n  return new Array(+width + 1 - (number.toString()).length).join('0') + number;\r\n}\r\n\r\nfunction orderedSectionName(index, sectionId) {\r\n  return `${padNumberWithZeros(index, 4)}--${sectionId}`;\r\n}\r\n\r\nfunction cappedTimeElapsed({\r\n  maxTimeInSeconds,\r\n  startTime,\r\n}) {\r\n  const elapsedTime = Math.round(\r\n    (new Date() - startTime) / 1000,\r\n  );\r\n  return elapsedTime >= maxTimeInSeconds\r\n    ? maxTimeInSeconds\r\n    : elapsedTime;\r\n}\r\n\r\nexport function sendEnteredNarrationAnalytics({\r\n  enteringNarrationIndex,\r\n  enteringSectionId,\r\n  enteringSectionIndex,\r\n  pageLoadStartTime,\r\n  maxTimeInSeconds,\r\n}) {\r\n  const section = orderedSectionName(enteringSectionIndex, enteringSectionId);\r\n\r\n  window.ga('send', {\r\n    hitType: 'event',\r\n    eventCategory: 'Narration Entry Time (seconds since page load)',\r\n    eventAction: `${section}--${enteringNarrationIndex}`,\r\n    eventLabel: `Entered narration #${enteringNarrationIndex} (EventValue) seconds since page load`,\r\n    eventValue: cappedTimeElapsed({\r\n      maxTimeInSeconds,\r\n      startTime: pageLoadStartTime,\r\n    }),\r\n  });\r\n}\r\n\r\nexport function sendExitedNarrationAnalytics({\r\n  exitingNarrationIndex,\r\n  exitedSectionId,\r\n  exitedSectionIndex,\r\n  maxTimeInSeconds,\r\n  timeEntered,\r\n}) {\r\n  const section = orderedSectionName(exitedSectionIndex, exitedSectionId);\r\n\r\n  window.ga('send', {\r\n    hitType: 'event',\r\n    eventCategory: 'Time in Narration (seconds)',\r\n    eventAction: `${section}--${exitingNarrationIndex}`,\r\n    eventLabel: `Exited ${section}, narration #${exitingNarrationIndex} after (EventValue) seconds`,\r\n    eventValue: cappedTimeElapsed({\r\n      startTime: timeEntered,\r\n      maxTimeInSeconds,\r\n    }),\r\n  });\r\n}\r\n\r\nexport function sendEnteredSectionAnalytics({\r\n  enteringSectionId,\r\n  enteringSectionIndex,\r\n  pageLoadStartTime,\r\n  maxTimeInSeconds,\r\n}) {\r\n  window.ga('send', {\r\n    hitType: 'event',\r\n    eventCategory: 'Section Entry Time (seconds since page load)',\r\n    eventAction: orderedSectionName(enteringSectionIndex, enteringSectionId),\r\n    eventLabel: `Entered section ${enteringSectionId} (EventValue) seconds since page load`,\r\n    eventValue: cappedTimeElapsed({\r\n      maxTimeInSeconds,\r\n      startTime: pageLoadStartTime,\r\n    }),\r\n  });\r\n}\r\n\r\nexport function sendExitedSectionAnalytics({\r\n  exitedNarrationIndex,\r\n  exitedSectionId,\r\n  exitedSectionIndex,\r\n  maxTimeInSeconds,\r\n  timeEntered,\r\n}) {\r\n  const section = orderedSectionName(exitedSectionIndex, exitedSectionId);\r\n\r\n  window.ga('send', {\r\n    hitType: 'event',\r\n    eventCategory: 'Time in Section (seconds)',\r\n    eventAction: section,\r\n    eventLabel: `Exited ${section}, narration #${exitedNarrationIndex} after (EventValue) seconds`,\r\n    eventValue: cappedTimeElapsed({\r\n      startTime: timeEntered,\r\n      maxTimeInSeconds,\r\n    }),\r\n  });\r\n}\r\n\r\nexport function sendScrollToAnalytics({\r\n  enteringSectionId,\r\n  enteringSectionIndex,\r\n  enteringNarrationIndex: enterNIndex,\r\n  maxTimeInSeconds,\r\n  pageLoadStartTime,\r\n  exitedSectionId,\r\n  exitedSectionIndex,\r\n  exitedNarrationIndex: exitNIndex,\r\n}) {\r\n  window.ga('send', {\r\n    hitType: 'event',\r\n    eventCategory: 'Scroll From-To (SectionIndex---SectionId---NarrationIndex)',\r\n    eventAction: `From ${orderedSectionName(exitedSectionIndex, exitedSectionId)}--${exitNIndex}`,\r\n    eventLabel: `To ${orderedSectionName(enteringSectionIndex, enteringSectionId)}--${enterNIndex}`,\r\n    eventValue: cappedTimeElapsed({ maxTimeInSeconds, startTime: pageLoadStartTime }),\r\n  });\r\n  window.ga('send', {\r\n    hitType: 'event',\r\n    eventCategory: 'Scroll To-From (SectionIndex---SectionId---NarrationIndex)',\r\n    eventAction: `To ${orderedSectionName(enteringSectionIndex, enteringSectionId)}--${exitNIndex}`,\r\n    eventLabel: `From ${orderedSectionName(exitedSectionIndex, exitedSectionId)}--${enterNIndex}`,\r\n    eventValue: cappedTimeElapsed({ maxTimeInSeconds, startTime: pageLoadStartTime }),\r\n  });\r\n}\r\n","C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\fetchUtils.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\graphUpdates.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\scrollProgress.js",[],"C:\\Users\\user\\Desktop\\Ryan's Stuff\\Client Projects\\AddScrollteller Client\\glidaa.com\\src\\ScrollyTeller\\utils\\vhToPxFunctions.js",["102"],"/* global document */\r\nimport { isNil } from 'lodash-es';\r\n\r\nexport function vhToNumericPx(vh) {\r\n  if (isNil(vh)) return undefined;\r\n\r\n  const { clientHeight: height } = document.documentElement;\r\n  const percent = parseFloat(vh) / 100;\r\n  return height * percent;\r\n}\r\n\r\nexport function vhToPx(vh) {\r\n  return `${vhToNumericPx(vh)}px`;\r\n}\r\n",{"ruleId":"103","replacedBy":"104"},{"ruleId":"105","replacedBy":"106"},{"ruleId":"107","severity":1,"message":"108","line":39,"column":9,"nodeType":"109","messageId":"110","endLine":39,"endColumn":12},{"ruleId":"111","severity":1,"message":"112","line":13,"column":1,"nodeType":"113","endLine":45,"endColumn":3},{"ruleId":"114","severity":1,"message":"115","line":1,"column":11,"nodeType":"116","messageId":"117","endLine":1,"endColumn":19},{"ruleId":"114","severity":1,"message":"118","line":1,"column":21,"nodeType":"116","messageId":"117","endLine":1,"endColumn":27},{"ruleId":"114","severity":1,"message":"118","line":1,"column":11,"nodeType":"116","messageId":"117","endLine":1,"endColumn":17},{"ruleId":"111","severity":1,"message":"112","line":1,"column":1,"nodeType":"113","endLine":12,"endColumn":3},{"ruleId":"114","severity":1,"message":"118","line":1,"column":11,"nodeType":"116","messageId":"117","endLine":1,"endColumn":17},{"ruleId":"119","severity":1,"message":"120","line":1,"column":11,"nodeType":"121","messageId":"110","endLine":1,"endColumn":17},{"ruleId":"114","severity":1,"message":"115","line":1,"column":18,"nodeType":"116","messageId":"117","endLine":1,"endColumn":26},{"ruleId":"119","severity":1,"message":"122","line":1,"column":18,"nodeType":"121","messageId":"110","endLine":1,"endColumn":26},{"ruleId":"114","severity":1,"message":"118","line":1,"column":11,"nodeType":"116","messageId":"117","endLine":1,"endColumn":17},{"ruleId":"114","severity":1,"message":"115","line":1,"column":11,"nodeType":"116","messageId":"117","endLine":1,"endColumn":19},"no-native-reassign",["123"],"no-negated-in-lhs",["124"],"@typescript-eslint/no-unused-vars","'app' is assigned a value but never used.","Identifier","unusedVar","import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","no-redeclare","'document' is already defined as a built-in global variable.","Block","redeclaredAsBuiltin","'window' is already defined as a built-in global variable.","no-unused-vars","'window' is defined but never used.","Program","'document' is defined but never used.","no-global-assign","no-unsafe-negation"]